<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>surface_hopping.molecular_dynamics API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>surface_hopping.molecular_dynamics</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import random
import sys

import autograd.numpy as np
from scipy.integrate import solve_ivp

from .get_potential import get_gradients_and_nadvec
from .input_pes import nel, mass

hbar = 1.0


def update_x(x_current_l, v_current_l, a_current_l, dt_l):
    &#34;&#34;&#34; Update x with velocity-verlet algorithm.

    Parameters
    ----------
    x_current_l: float
        Nuclear coordinate for the current time-step
    v_current_l: float
        Nuclear velocity for the current time-step
    a_current_l: float
        Acceleration for the current time-step
    dt_l: float
        Time-step

    Returns
    -------
    float
        Updated nuclear coordinate

    Notes
    -----

    Velocity-verlet algorithm:
    x(t + dt) = x(t) + v(t)*dt + 0.5*a(t)*dt**2
    &#34;&#34;&#34;

    x_new = x_current_l + v_current_l * dt_l + 0.5 * a_current_l * (dt_l ** 2)

    return x_new


def update_v(v_current_l, a_current_l, a_new, dt_l):
    &#34;&#34;&#34; Update x with velocity-verlet algorithm.

    Parameters
    ----------
    v_current_l: float
        Nuclear velocity for the current time-step
    a_current_l: float
        Acceleration for the current time-step
    a_new: float
        Acceleration after the position update
    dt_l: float
        Time-step

    Returns
    -------
    float
        Updated velocity

    Notes
    -----

    Velocity-verlet algorithm:
    v(t + dt) = v(t) + 0.5*(a(t) + a(t + dt))*dt
    &#34;&#34;&#34;

    v_new = v_current_l + 0.5 * (a_current_l + a_new) * dt_l

    return v_new


def call_surface_hopping(c_coeff, v_current_l, f_current, e_ad, dt_l, cstate_l):
    &#34;&#34;&#34;Solve electronic TDSE, Compute hopping probabilities, adjust momentum

    Parameters
    ----------
    c_coeff: array_like
        Electronic wavefunction coefficients
    v_current_l: float
        Current nuclear velocity
    f_current: array_like
        Current forces on electronic states
    e_ad: array_like
        Electronic adiabatic energies
    dt_l: float
        Time-step
    cstate_l: int
        Current electronic state

    Returns
    -------
    int
        Current electronic state
    float
        New velocity if momentum has been adjusted
    bool
        Whether a hopping has occurred or not

    &#34;&#34;&#34;

    # Create density matrix
    amat = np.outer(c_coeff, np.conj(c_coeff))

    # Set HOP to False
    HOP = False

    # Create bmat and gmat
    bmat = np.zeros((nel * (nel - 1)) // 2)
    gmat = np.zeros((nel * (nel - 1)) // 2)

    # Generate random number
    rand_num = random.uniform(0, 1)

    # Compute hopping probabilities (adiabatic) and decide whether to hop or not
    for a in range(nel):
        if a != cstate_l:
            print(&#39;Compute hopping from state&#39;, cstate_l, &#39;to state&#39;, a)
            k = (nel * nel // 2) - (nel - a) * (nel - a) // 2 + cstate_l - a - 1
            # Note that NACVEC satisfies: f_ab = - (f_ba)*
            if a &gt; cstate_l:
                bmat[k] = - 2. * np.real(np.conj(amat[cstate_l, a])
                                         * (np.dot(v_current_l, f_current[k])))
            else:
                bmat[k] = - 2. * np.real(np.conj(amat[cstate_l, a])
                                         * (np.dot(v_current_l, -np.conj(f_current[k]))))
            gmat[k] = max(0., (bmat[k] / np.real(amat[cstate_l, cstate_l])) * dt_l)
            print(&#39;k, gmat, rand_num&#39;, k, gmat[k], rand_num)
            if gmat[k] &gt; rand_num:
                HOP = True
                print(&#39;Hopping from state&#39;, cstate_l, &#39;to state&#39;, a)
                pstate = cstate_l
                cstate_l = a
                break
            else:
                pstate = cstate_l
                continue
        else:
            pass

    # If a hop has occurred, adjust momentum and check for frustrated hops
    if HOP:
        # Note that hop has occurred from pstate to cstate (new def)
        # Compute quantities aij, bij (from the change in kinetic energy)
        k = (nel * nel // 2) - (nel - pstate) * \
            (nel - pstate) // 2 + cstate_l - pstate - 1
        if pstate &lt; cstate_l:
            f_current[k] = - np.conj(f_current[k])
        else:
            pass
        ak = (f_current[k] ** 2) / (2. * mass)
        bk = f_current[k] * v_current_l
        resid = bk ** 2 + 4. * ak * (e_ad[pstate] - e_ad[cstate_l])

        # Check for real roots
        if resid &lt; 0.:
            print(&#39;Frustated hop occurred. Reverse hopping and velocities&#39;)
            gamma = bk / ak
            v_new = v_current_l - gamma * (f_current[k] / mass)
            # Reverse Hopping too!
            HOP = False
            temp = cstate_l
            cstate_l = pstate
            pstate = temp
        else:
            print(&#39;Adjusting momentum in a regular way after HOP&#39;)
            if bk &lt; 0.:
                gamma = (bk + np.sqrt(resid)) / (2. * ak)
            else:
                gamma = (bk - np.sqrt(resid)) / (2. * ak)
            v_new = v_current_l - gamma * (f_current[k] / mass)
    else:
        # No HOP has occurred. Exit gracefully!
        v_new = v_current_l

    return cstate_l, v_new, HOP


def add_decoherence(coeff_current, cstate_l, e_ad, e_kin, dt_l):
    &#34;&#34;&#34;Decoherence correction for electronic populations

    Parameters
    ----------
    coeff_current: array_like
        Current wavefunction coefficients, before decoherence corrected
    cstate_l: int
        Current electronic state
    e_ad: array_like
        Electronic adiabatic energies
    e_kin: float
        Nuclear kinetic energy
    dt_l: float
        Time-step

    Returns
    -------
    array_like
        Decoherence corrected wavefunction coefficients

    Notes
    -----
    Standard decoherence corrections by Zhu-Truhlar (2004-2005)
    Eq. 13-15 in Mario&#39;s 2011 review. Eq. 14 HAS AN ERROR (Square missing!)

    &#34;&#34;&#34;

    # Hartree (Recommended value. Pourquoi? What effect does it have?)
    alpha = 0.1

    # Initialize
    tau = np.zeros(nel)
    new_coeff = np.zeros(nel, dtype=&#39;complex64&#39;)

    # Compute tau and coeffs other than cstate
    for n in range(nel):
        if n != cstate_l:
            tau[n] = (hbar / (abs(e_ad[n] - e_ad[cstate_l]))) * (1. + (alpha / e_kin))
            new_coeff[n] = coeff_current[n] * (np.exp(-dt_l / tau[n]))
        else:
            pass

    # Compute new coeff for current state
    sum_pop = 0.0
    for n in range(nel):
        if n != cstate_l:
            sum_pop += np.abs(new_coeff[n]) ** 2
        else:
            pass

    new_coeff[cstate_l] = coeff_current[cstate_l] * np.sqrt((1. - sum_pop) / ((np.abs(coeff_current[cstate_l])) ** 2))

    return new_coeff


def do_main_loop(x_init, v_init, t_init, t_final, cstate, decoherence, dt):
    &#34;&#34;&#34;Main loop to drive the dynamics (driver function)

    Parameters
    ----------
    x_init: float
        Initial position
    v_init: float
        Initial momentum
    t_init: float
        Starting time of dynamics
    t_final: float
        Ending time of dynamics
    cstate: int
        Current electronic state (surface)
    decoherence: bool
        Whether to add decoherence or not
    dt: float
        Time-step for the simulation

    Returns
    -------
    None

    &#34;&#34;&#34;

    sys.stdout = open(&#39;output_sh_dyn&#39;, &#39;w&#39;)

    print()
    print(&#39;==========================&#39;)
    print(&#39;Welcome to HIP-HOP-1D&#39;)
    print(&#39;A miniature FSSH program&#39;)
    print(&#39;Author: Prateek Goel&#39;)
    print(&#39;Aix Marseille University&#39;)
    print(&#39;==========================&#39;)
    print()

    t = t_init  # Set initial time to tinit

    # Initial position and velocity
    # NOTE: Have to think more about this as it needs to be
    # replaced for every ensemble
    x_previous = x_init
    v_previous = v_init

    # Call PES program to get Energies, Gradients, Nonadiabatic Couplings
    E_previous, G_previous, F_previous = get_gradients_and_nadvec(x_previous)
    a_previous = -G_previous[cstate] / mass

    # Intialize electronic coefficients vector
    ci_previous = np.zeros(nel, dtype=&#39;complex64&#39;)
    ci_previous[cstate] = 1.0

    count = 0
    gwrite = open(&#39;populations&#39;, &#39;w&#39;)
    fwrite = open(&#39;md_data&#39;, &#39;w&#39;)
    fwrite.write(&#39;#Time         x       v       E       Norm    HOP   CSTATE&#39;)
    fwrite.write(&#39;\n&#39;)
    # Start main loop
    while t &lt; t_final:

        print(&#39;Current cycle&#39;, count)
        print()
        print(&#39;Current time&#39;, t)
        print()
        print(&#39;Current state&#39;, cstate)
        print()

        # Solve Nuclear Dynamics
        x_current = update_x(x_previous, v_previous, a_previous, dt)
        E_current, G_current, F_current = get_gradients_and_nadvec(x_current)
        a_current = -G_current[cstate] / mass
        v_current = update_v(v_previous, a_previous, a_current, dt)

        # TDSE Propagator Matrix
        e_prop_mat = np.zeros((nel, nel), dtype=&#39;complex64&#39;)
        diag_elements = -1j * (E_current - E_current[0]) / hbar
        np.fill_diagonal(e_prop_mat, diag_elements)
        for a in range(nel):
            for b in range(nel):
                if a != b and a &gt; b:
                    k = (nel * nel // 2) - (nel - a) * (nel - a) // 2 + b - a - 1
                    e_prop_mat[a, b] = - np.dot(v_current, F_current[k])
                    e_prop_mat[b, a] = - \
                        np.dot(v_current, - np.conj(F_current[k]))
                else:
                    pass

        # Solve ODE. Ugh!
        func_prop = lambda tloc, yvec: np.dot(e_prop_mat, yvec)
        ci_current = solve_ivp(func_prop, (t, t + dt), ci_previous)[&#39;y&#39;][:, 1]

        # Norm (or total population, should sum to 1.0)
        total_population = 0.0
        for i in range(nel):
            total_population += abs(ci_current[i]) ** 2

        # =============================================================
        # Or do the simple thing. Create propagator and propagate. Duh!
        # =============================================================

        # p_val, p_vec = np.linalg.eig(e_prop_mat*dt)
        # p_mat_exp = np.conj(p_vec).T @ (expm(np.diag(p_val)) @ p_vec)
        # ci_current_direct = np.dot(p_mat_exp, ci_previous)
        # pop_propagate = abs(ci_current_direct[0])**2 + abs(ci_current_direct[1])**2

        # Kinetic Energy
        Ekin = 0.5 * mass * (v_current ** 2)

        # Add decoherence
        # Note that ci_current gets overwritten by the previous coeff (obtained by solving TDSE)
        if decoherence:
            ci_current = add_decoherence(
                ci_current, cstate, E_current, Ekin, dt)
        else:
            pass

        # Call hopping subroutine: calculate hopping probability and adjust momentum
        cstate, v_current, hop_status = call_surface_hopping(
            ci_current, v_current, F_current, E_current, dt, cstate)

        # Set current to previous
        x_previous = x_current
        v_previous = v_current
        a_previous = a_current
        ci_previous = np.copy(ci_current)

        # Update time
        t = t + dt

        # Update time counter
        count += 1

        # Write electronic coefficients to file
        gwrite.write(&#34;{:12.6f}&#34;.format(t) + &#39;\t\t&#39;)
        for i in range(nel):
            gwrite.write(&#34;{:15.10f}&#34;.format(abs(ci_current[i]) ** 2) + &#39;\t\t&#39;)
        gwrite.write(&#39;\n&#39;)

        # Write MD data to file
        fwrite.write(&#34;{:15.10f} {:15.10f} {:15.10f} {:15.10f} {:15.10f} {:8d} {:8d}&#34;.format(
            t, x_current, v_current, E_current[cstate], total_population, int(hop_status), cstate))
        fwrite.write(&#39;\n&#39;)

    fwrite.close()
    gwrite.close()

    return

print(update_v(1.0, 0.1, 0.15, 0.2))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="surface_hopping.molecular_dynamics.add_decoherence"><code class="name flex">
<span>def <span class="ident">add_decoherence</span></span>(<span>coeff_current, cstate_l, e_ad, e_kin, dt_l)</span>
</code></dt>
<dd>
<div class="desc"><p>Decoherence correction for electronic populations</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coeff_current</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Current wavefunction coefficients, before decoherence corrected</dd>
<dt><strong><code>cstate_l</code></strong> :&ensp;<code>int</code></dt>
<dd>Current electronic state</dd>
<dt><strong><code>e_ad</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Electronic adiabatic energies</dd>
<dt><strong><code>e_kin</code></strong> :&ensp;<code>float</code></dt>
<dd>Nuclear kinetic energy</dd>
<dt><strong><code>dt_l</code></strong> :&ensp;<code>float</code></dt>
<dd>Time-step</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>array_like</code></dt>
<dd>Decoherence corrected wavefunction coefficients</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Standard decoherence corrections by Zhu-Truhlar (2004-2005)
Eq. 13-15 in Mario's 2011 review. Eq. 14 HAS AN ERROR (Square missing!)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_decoherence(coeff_current, cstate_l, e_ad, e_kin, dt_l):
    &#34;&#34;&#34;Decoherence correction for electronic populations

    Parameters
    ----------
    coeff_current: array_like
        Current wavefunction coefficients, before decoherence corrected
    cstate_l: int
        Current electronic state
    e_ad: array_like
        Electronic adiabatic energies
    e_kin: float
        Nuclear kinetic energy
    dt_l: float
        Time-step

    Returns
    -------
    array_like
        Decoherence corrected wavefunction coefficients

    Notes
    -----
    Standard decoherence corrections by Zhu-Truhlar (2004-2005)
    Eq. 13-15 in Mario&#39;s 2011 review. Eq. 14 HAS AN ERROR (Square missing!)

    &#34;&#34;&#34;

    # Hartree (Recommended value. Pourquoi? What effect does it have?)
    alpha = 0.1

    # Initialize
    tau = np.zeros(nel)
    new_coeff = np.zeros(nel, dtype=&#39;complex64&#39;)

    # Compute tau and coeffs other than cstate
    for n in range(nel):
        if n != cstate_l:
            tau[n] = (hbar / (abs(e_ad[n] - e_ad[cstate_l]))) * (1. + (alpha / e_kin))
            new_coeff[n] = coeff_current[n] * (np.exp(-dt_l / tau[n]))
        else:
            pass

    # Compute new coeff for current state
    sum_pop = 0.0
    for n in range(nel):
        if n != cstate_l:
            sum_pop += np.abs(new_coeff[n]) ** 2
        else:
            pass

    new_coeff[cstate_l] = coeff_current[cstate_l] * np.sqrt((1. - sum_pop) / ((np.abs(coeff_current[cstate_l])) ** 2))

    return new_coeff</code></pre>
</details>
</dd>
<dt id="surface_hopping.molecular_dynamics.call_surface_hopping"><code class="name flex">
<span>def <span class="ident">call_surface_hopping</span></span>(<span>c_coeff, v_current_l, f_current, e_ad, dt_l, cstate_l)</span>
</code></dt>
<dd>
<div class="desc"><p>Solve electronic TDSE, Compute hopping probabilities, adjust momentum</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c_coeff</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Electronic wavefunction coefficients</dd>
<dt><strong><code>v_current_l</code></strong> :&ensp;<code>float</code></dt>
<dd>Current nuclear velocity</dd>
<dt><strong><code>f_current</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Current forces on electronic states</dd>
<dt><strong><code>e_ad</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Electronic adiabatic energies</dd>
<dt><strong><code>dt_l</code></strong> :&ensp;<code>float</code></dt>
<dd>Time-step</dd>
<dt><strong><code>cstate_l</code></strong> :&ensp;<code>int</code></dt>
<dd>Current electronic state</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Current electronic state</dd>
<dt><code>float</code></dt>
<dd>New velocity if momentum has been adjusted</dd>
<dt><code>bool</code></dt>
<dd>Whether a hopping has occurred or not</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call_surface_hopping(c_coeff, v_current_l, f_current, e_ad, dt_l, cstate_l):
    &#34;&#34;&#34;Solve electronic TDSE, Compute hopping probabilities, adjust momentum

    Parameters
    ----------
    c_coeff: array_like
        Electronic wavefunction coefficients
    v_current_l: float
        Current nuclear velocity
    f_current: array_like
        Current forces on electronic states
    e_ad: array_like
        Electronic adiabatic energies
    dt_l: float
        Time-step
    cstate_l: int
        Current electronic state

    Returns
    -------
    int
        Current electronic state
    float
        New velocity if momentum has been adjusted
    bool
        Whether a hopping has occurred or not

    &#34;&#34;&#34;

    # Create density matrix
    amat = np.outer(c_coeff, np.conj(c_coeff))

    # Set HOP to False
    HOP = False

    # Create bmat and gmat
    bmat = np.zeros((nel * (nel - 1)) // 2)
    gmat = np.zeros((nel * (nel - 1)) // 2)

    # Generate random number
    rand_num = random.uniform(0, 1)

    # Compute hopping probabilities (adiabatic) and decide whether to hop or not
    for a in range(nel):
        if a != cstate_l:
            print(&#39;Compute hopping from state&#39;, cstate_l, &#39;to state&#39;, a)
            k = (nel * nel // 2) - (nel - a) * (nel - a) // 2 + cstate_l - a - 1
            # Note that NACVEC satisfies: f_ab = - (f_ba)*
            if a &gt; cstate_l:
                bmat[k] = - 2. * np.real(np.conj(amat[cstate_l, a])
                                         * (np.dot(v_current_l, f_current[k])))
            else:
                bmat[k] = - 2. * np.real(np.conj(amat[cstate_l, a])
                                         * (np.dot(v_current_l, -np.conj(f_current[k]))))
            gmat[k] = max(0., (bmat[k] / np.real(amat[cstate_l, cstate_l])) * dt_l)
            print(&#39;k, gmat, rand_num&#39;, k, gmat[k], rand_num)
            if gmat[k] &gt; rand_num:
                HOP = True
                print(&#39;Hopping from state&#39;, cstate_l, &#39;to state&#39;, a)
                pstate = cstate_l
                cstate_l = a
                break
            else:
                pstate = cstate_l
                continue
        else:
            pass

    # If a hop has occurred, adjust momentum and check for frustrated hops
    if HOP:
        # Note that hop has occurred from pstate to cstate (new def)
        # Compute quantities aij, bij (from the change in kinetic energy)
        k = (nel * nel // 2) - (nel - pstate) * \
            (nel - pstate) // 2 + cstate_l - pstate - 1
        if pstate &lt; cstate_l:
            f_current[k] = - np.conj(f_current[k])
        else:
            pass
        ak = (f_current[k] ** 2) / (2. * mass)
        bk = f_current[k] * v_current_l
        resid = bk ** 2 + 4. * ak * (e_ad[pstate] - e_ad[cstate_l])

        # Check for real roots
        if resid &lt; 0.:
            print(&#39;Frustated hop occurred. Reverse hopping and velocities&#39;)
            gamma = bk / ak
            v_new = v_current_l - gamma * (f_current[k] / mass)
            # Reverse Hopping too!
            HOP = False
            temp = cstate_l
            cstate_l = pstate
            pstate = temp
        else:
            print(&#39;Adjusting momentum in a regular way after HOP&#39;)
            if bk &lt; 0.:
                gamma = (bk + np.sqrt(resid)) / (2. * ak)
            else:
                gamma = (bk - np.sqrt(resid)) / (2. * ak)
            v_new = v_current_l - gamma * (f_current[k] / mass)
    else:
        # No HOP has occurred. Exit gracefully!
        v_new = v_current_l

    return cstate_l, v_new, HOP</code></pre>
</details>
</dd>
<dt id="surface_hopping.molecular_dynamics.do_main_loop"><code class="name flex">
<span>def <span class="ident">do_main_loop</span></span>(<span>x_init, v_init, t_init, t_final, cstate, decoherence, dt)</span>
</code></dt>
<dd>
<div class="desc"><p>Main loop to drive the dynamics (driver function)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x_init</code></strong> :&ensp;<code>float</code></dt>
<dd>Initial position</dd>
<dt><strong><code>v_init</code></strong> :&ensp;<code>float</code></dt>
<dd>Initial momentum</dd>
<dt><strong><code>t_init</code></strong> :&ensp;<code>float</code></dt>
<dd>Starting time of dynamics</dd>
<dt><strong><code>t_final</code></strong> :&ensp;<code>float</code></dt>
<dd>Ending time of dynamics</dd>
<dt><strong><code>cstate</code></strong> :&ensp;<code>int</code></dt>
<dd>Current electronic state (surface)</dd>
<dt><strong><code>decoherence</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to add decoherence or not</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time-step for the simulation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_main_loop(x_init, v_init, t_init, t_final, cstate, decoherence, dt):
    &#34;&#34;&#34;Main loop to drive the dynamics (driver function)

    Parameters
    ----------
    x_init: float
        Initial position
    v_init: float
        Initial momentum
    t_init: float
        Starting time of dynamics
    t_final: float
        Ending time of dynamics
    cstate: int
        Current electronic state (surface)
    decoherence: bool
        Whether to add decoherence or not
    dt: float
        Time-step for the simulation

    Returns
    -------
    None

    &#34;&#34;&#34;

    sys.stdout = open(&#39;output_sh_dyn&#39;, &#39;w&#39;)

    print()
    print(&#39;==========================&#39;)
    print(&#39;Welcome to HIP-HOP-1D&#39;)
    print(&#39;A miniature FSSH program&#39;)
    print(&#39;Author: Prateek Goel&#39;)
    print(&#39;Aix Marseille University&#39;)
    print(&#39;==========================&#39;)
    print()

    t = t_init  # Set initial time to tinit

    # Initial position and velocity
    # NOTE: Have to think more about this as it needs to be
    # replaced for every ensemble
    x_previous = x_init
    v_previous = v_init

    # Call PES program to get Energies, Gradients, Nonadiabatic Couplings
    E_previous, G_previous, F_previous = get_gradients_and_nadvec(x_previous)
    a_previous = -G_previous[cstate] / mass

    # Intialize electronic coefficients vector
    ci_previous = np.zeros(nel, dtype=&#39;complex64&#39;)
    ci_previous[cstate] = 1.0

    count = 0
    gwrite = open(&#39;populations&#39;, &#39;w&#39;)
    fwrite = open(&#39;md_data&#39;, &#39;w&#39;)
    fwrite.write(&#39;#Time         x       v       E       Norm    HOP   CSTATE&#39;)
    fwrite.write(&#39;\n&#39;)
    # Start main loop
    while t &lt; t_final:

        print(&#39;Current cycle&#39;, count)
        print()
        print(&#39;Current time&#39;, t)
        print()
        print(&#39;Current state&#39;, cstate)
        print()

        # Solve Nuclear Dynamics
        x_current = update_x(x_previous, v_previous, a_previous, dt)
        E_current, G_current, F_current = get_gradients_and_nadvec(x_current)
        a_current = -G_current[cstate] / mass
        v_current = update_v(v_previous, a_previous, a_current, dt)

        # TDSE Propagator Matrix
        e_prop_mat = np.zeros((nel, nel), dtype=&#39;complex64&#39;)
        diag_elements = -1j * (E_current - E_current[0]) / hbar
        np.fill_diagonal(e_prop_mat, diag_elements)
        for a in range(nel):
            for b in range(nel):
                if a != b and a &gt; b:
                    k = (nel * nel // 2) - (nel - a) * (nel - a) // 2 + b - a - 1
                    e_prop_mat[a, b] = - np.dot(v_current, F_current[k])
                    e_prop_mat[b, a] = - \
                        np.dot(v_current, - np.conj(F_current[k]))
                else:
                    pass

        # Solve ODE. Ugh!
        func_prop = lambda tloc, yvec: np.dot(e_prop_mat, yvec)
        ci_current = solve_ivp(func_prop, (t, t + dt), ci_previous)[&#39;y&#39;][:, 1]

        # Norm (or total population, should sum to 1.0)
        total_population = 0.0
        for i in range(nel):
            total_population += abs(ci_current[i]) ** 2

        # =============================================================
        # Or do the simple thing. Create propagator and propagate. Duh!
        # =============================================================

        # p_val, p_vec = np.linalg.eig(e_prop_mat*dt)
        # p_mat_exp = np.conj(p_vec).T @ (expm(np.diag(p_val)) @ p_vec)
        # ci_current_direct = np.dot(p_mat_exp, ci_previous)
        # pop_propagate = abs(ci_current_direct[0])**2 + abs(ci_current_direct[1])**2

        # Kinetic Energy
        Ekin = 0.5 * mass * (v_current ** 2)

        # Add decoherence
        # Note that ci_current gets overwritten by the previous coeff (obtained by solving TDSE)
        if decoherence:
            ci_current = add_decoherence(
                ci_current, cstate, E_current, Ekin, dt)
        else:
            pass

        # Call hopping subroutine: calculate hopping probability and adjust momentum
        cstate, v_current, hop_status = call_surface_hopping(
            ci_current, v_current, F_current, E_current, dt, cstate)

        # Set current to previous
        x_previous = x_current
        v_previous = v_current
        a_previous = a_current
        ci_previous = np.copy(ci_current)

        # Update time
        t = t + dt

        # Update time counter
        count += 1

        # Write electronic coefficients to file
        gwrite.write(&#34;{:12.6f}&#34;.format(t) + &#39;\t\t&#39;)
        for i in range(nel):
            gwrite.write(&#34;{:15.10f}&#34;.format(abs(ci_current[i]) ** 2) + &#39;\t\t&#39;)
        gwrite.write(&#39;\n&#39;)

        # Write MD data to file
        fwrite.write(&#34;{:15.10f} {:15.10f} {:15.10f} {:15.10f} {:15.10f} {:8d} {:8d}&#34;.format(
            t, x_current, v_current, E_current[cstate], total_population, int(hop_status), cstate))
        fwrite.write(&#39;\n&#39;)

    fwrite.close()
    gwrite.close()

    return</code></pre>
</details>
</dd>
<dt id="surface_hopping.molecular_dynamics.update_v"><code class="name flex">
<span>def <span class="ident">update_v</span></span>(<span>v_current_l, a_current_l, a_new, dt_l)</span>
</code></dt>
<dd>
<div class="desc"><p>Update x with velocity-verlet algorithm.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>v_current_l</code></strong> :&ensp;<code>float</code></dt>
<dd>Nuclear velocity for the current time-step</dd>
<dt><strong><code>a_current_l</code></strong> :&ensp;<code>float</code></dt>
<dd>Acceleration for the current time-step</dd>
<dt><strong><code>a_new</code></strong> :&ensp;<code>float</code></dt>
<dd>Acceleration after the position update</dd>
<dt><strong><code>dt_l</code></strong> :&ensp;<code>float</code></dt>
<dd>Time-step</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Updated velocity</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Velocity-verlet algorithm:
v(t + dt) = v(t) + 0.5<em>(a(t) + a(t + dt))</em>dt</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_v(v_current_l, a_current_l, a_new, dt_l):
    &#34;&#34;&#34; Update x with velocity-verlet algorithm.

    Parameters
    ----------
    v_current_l: float
        Nuclear velocity for the current time-step
    a_current_l: float
        Acceleration for the current time-step
    a_new: float
        Acceleration after the position update
    dt_l: float
        Time-step

    Returns
    -------
    float
        Updated velocity

    Notes
    -----

    Velocity-verlet algorithm:
    v(t + dt) = v(t) + 0.5*(a(t) + a(t + dt))*dt
    &#34;&#34;&#34;

    v_new = v_current_l + 0.5 * (a_current_l + a_new) * dt_l

    return v_new</code></pre>
</details>
</dd>
<dt id="surface_hopping.molecular_dynamics.update_x"><code class="name flex">
<span>def <span class="ident">update_x</span></span>(<span>x_current_l, v_current_l, a_current_l, dt_l)</span>
</code></dt>
<dd>
<div class="desc"><p>Update x with velocity-verlet algorithm.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x_current_l</code></strong> :&ensp;<code>float</code></dt>
<dd>Nuclear coordinate for the current time-step</dd>
<dt><strong><code>v_current_l</code></strong> :&ensp;<code>float</code></dt>
<dd>Nuclear velocity for the current time-step</dd>
<dt><strong><code>a_current_l</code></strong> :&ensp;<code>float</code></dt>
<dd>Acceleration for the current time-step</dd>
<dt><strong><code>dt_l</code></strong> :&ensp;<code>float</code></dt>
<dd>Time-step</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Updated nuclear coordinate</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Velocity-verlet algorithm:
x(t + dt) = x(t) + v(t)<em>dt + 0.5</em>a(t)<em>dt</em>*2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_x(x_current_l, v_current_l, a_current_l, dt_l):
    &#34;&#34;&#34; Update x with velocity-verlet algorithm.

    Parameters
    ----------
    x_current_l: float
        Nuclear coordinate for the current time-step
    v_current_l: float
        Nuclear velocity for the current time-step
    a_current_l: float
        Acceleration for the current time-step
    dt_l: float
        Time-step

    Returns
    -------
    float
        Updated nuclear coordinate

    Notes
    -----

    Velocity-verlet algorithm:
    x(t + dt) = x(t) + v(t)*dt + 0.5*a(t)*dt**2
    &#34;&#34;&#34;

    x_new = x_current_l + v_current_l * dt_l + 0.5 * a_current_l * (dt_l ** 2)

    return x_new</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="surface_hopping" href="index.html">surface_hopping</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="surface_hopping.molecular_dynamics.add_decoherence" href="#surface_hopping.molecular_dynamics.add_decoherence">add_decoherence</a></code></li>
<li><code><a title="surface_hopping.molecular_dynamics.call_surface_hopping" href="#surface_hopping.molecular_dynamics.call_surface_hopping">call_surface_hopping</a></code></li>
<li><code><a title="surface_hopping.molecular_dynamics.do_main_loop" href="#surface_hopping.molecular_dynamics.do_main_loop">do_main_loop</a></code></li>
<li><code><a title="surface_hopping.molecular_dynamics.update_v" href="#surface_hopping.molecular_dynamics.update_v">update_v</a></code></li>
<li><code><a title="surface_hopping.molecular_dynamics.update_x" href="#surface_hopping.molecular_dynamics.update_x">update_x</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>